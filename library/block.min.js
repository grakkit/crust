const TileState=Java.type("org.bukkit.block.TileState"),Directional=Java.type("org.bukkit.block.data.Directional"),NamespacedKey=Java.type("org.bukkit.NamespacedKey"),PersistentDataType=Java.type("org.bukkit.persistence.PersistentDataType"),PersistentDataHolder=Java.type("org.bukkit.persistence.PersistentDataHolder");export const wrapper=(_,$)=>instance=>{const block={get data(){const state=instance.getState();if(state instanceof TileState){const container=state.getPersistentDataContainer();return _.object(_.array(container.getRaw().entrySet()),entry=>{const directory=new NamespacedKey(...entry.getKey().split(":"));if(directory.getNamespace()===core.plugin.getName()){let value=_.base.decode(entry.getValue().asString());try{return{[`${directory.getKey()}`]:JSON.parse(value)}}catch(error){return{[`${directory.getKey()}`]:value}}}})}},set data(value){const state=instance.getState();if(state instanceof PersistentDataHolder){const container=state.getPersistentDataContainer();_.array(container.getRaw().entrySet()).forEach(entry=>{entry.getKey().split(":")[1]===core.plugin.getName()&&container.remove(new NamespacedKey(core.plugin,entry.getKey().getKey()))}),_.entries(value).forEach(entry=>{container.set(new NamespacedKey(core.plugin,entry.key),PersistentDataType.STRING,_.base.encode(JSON.stringify(core.serialize(entry.value))))}),state.update(!0)}},distance:(target,flat)=>{const input=$(":standardize",target);if(input)return"function"==typeof input[Symbol.iterator]?input.map(entry=>_.dist(block.location.instance,entry,flat)):_.dist(block.location.instance,input,flat)},drops:item=>{const drops=instance.getDrops($(":standardize",item));return 0===drops.length?null:drops},get facing(){const data=instance.getBlockData();if(data instanceof Directional)return $.blockFace[data.getFacing()]},set facing(value){const data=instance.getBlockData();data instanceof Directional&&(data.setFacing($.blockFace[value]),instance.setBlockData(data))},get instance(){return instance},get location(){return instance.getLocation().toVector()},get material(){return $.material[instance.getType()]},set material(value){instance.setType($.material[value]),"air"===value&&$(instance).glowing(!1)},spawn:lifeform=>$(`?${lifeform}`,instance.getLocation()),get vector(){return instance.getLocation().toVector()},get world(){return instance.getWorld()},get x(){return instance.getX()},get y(){return instance.getY()},get z(){return instance.getZ()}};return block};export const parser=(_,$)=>thing=>({data:server.createBlockData(thing.data),state:$("!stone").nbt(thing.state).meta().getBlockState()});export const chain=(_,$)=>({data:"appender",distance:"runner",drop:"runnerLink",drops:"runner",glowing:"setter",instance:"getter",location:"getterLink",material:"setter",serialize:thing=>({format:"block",data:thing.instance.getBlockData().getAsString(),state:$(`!${thing.material}`).meta(meta=>meta.setBlockState(thing.instance.getState())).nbt()}),spawn:"runnerLink",vector:"getterLink",world:"getter",x:"getter",y:"getter",z:"getter"});