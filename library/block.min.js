const TileState=Java.type("org.bukkit.block.TileState"),Directional=Java.type("org.bukkit.block.data.Directional"),NamespacedKey=Java.type("org.bukkit.NamespacedKey"),PersistentDataType=Java.type("org.bukkit.persistence.PersistentDataType");export const wrapper=(_,$)=>($("*blockBreak").if(!0).do(event=>$(event.getBlock()).glowing(!1)),instance=>{const block={get data(){const state=instance.getState();if(state instanceof TileState){const container=state.getPersistentDataContainer();return _.object(_.array(container.getRaw().entrySet()),entry=>{const directory=new NamespacedKey(...entry.getKey().split(":"));if(directory.getNamespace()===core.plugin.getName()){let value=_.base.decode(entry.getValue().asString());try{return{[`${directory.getKey()}`]:JSON.parse(value)}}catch(error){return{[`${directory.getKey()}`]:value}}}})}},set data(value){const state=instance.getState();if(state instanceof TileState){const container=state.getPersistentDataContainer();_.array(container.getRaw().entrySet()).forEach(entry=>{entry.getKey().split(":")[1]===core.plugin.getName()&&container.remove(new NamespacedKey(core.plugin,entry.getKey().getKey()))}),_.entries(value).forEach(entry=>{container.set(new NamespacedKey(core.plugin,entry.key),PersistentDataType.STRING,_.base.encode(JSON.stringify(core.serialize(entry.value))))}),state.update(!0)}},distance:(target,flat)=>_.dist(block.location,$("-",target),flat),drops:item=>{const drops=instance.getDrops($("-",item));return 0===drops.length?null:drops},get facing(){const data=instance.getBlockData();if(data instanceof Directional)return $.blockFace[data.getFacing()]},set facing(value){const data=instance.getBlockData();data instanceof Directional&&(data.setFacing($.blockFace[value]),instance.setBlockData(data))},get glowing(){return!!$(`@e[type=shulker,tag=grakkit,tag=glow,tag=${instance.getLocation().hashCode()}]`).instance()[0]},set glowing(value){const hash=instance.getLocation().hashCode().toString(),selector=`@e[type=shulker,tag=grakkit,tag=glow,tag=${hash}]`;!0!==value||$(selector).instance()[0]?!1===value&&$(selector).remove():$("?shulker",instance.getLocation()).tag("grakkit","glow",hash).effect("invisibility",{duration:1/0,amplifier:1}).ai(!1).collidable(!1).glowing(!0).invulnerable(!0).silent(!0).health(1).vitality(1)},get instance(){return instance},get location(){return $(instance.getLocation())},get material(){return $.material[instance.getType()]},set material(value){instance.setType($.material[value]),"air"===value&&$(`@e[type=shulker,tag=grakkit,tag=glow,tag=${instance.getLocation().hashCode()}]`).remove()},spawn:lifeform=>$(`?${lifeform}`,instance.getLocation()),get world(){return instance.getLocation().getWorld()}};return block});export const parser=(_,$)=>()=>({});export const chain=(_,$)=>({data:"appender",distance:"runner",drops:"runner",facing:"setter",glowing:"setter",instance:"getter",location:"getter",material:"setter",serialize:block=>({}),spawn:"runner",world:"getter"});