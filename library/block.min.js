const Material=Java.type("org.bukkit.Material"),BlockFace=Java.type("org.bukkit.block.BlockFace"),ItemStack=Java.type("org.bukkit.inventory.ItemStack"),Rotatable=Java.type("org.bukkit.block.data.Rotatable"),Directional=Java.type("org.bukkit.block.data.Directional"),LazyMetadataValue=Java.type("org.bukkit.metadata.LazyMetadataValue"),PersistentDataHolder=Java.type("org.bukkit.persistence.PersistentDataHolder");export const wrapper=(_,$)=>instance=>{const block={get data(){const state=instance.getState();if(state instanceof PersistentDataHolder)return $("+").data(state.getPersistentDataContainer())||{};{const entry=state.getMetadata("grakkit:jx")[0]||{value:()=>"{}"};try{return JSON.parse(entry.value())||{}}catch(error){return entry.value()}}},set data(value){if("object"!=typeof value)throw"TypeError: You must supply an object or null value!";{const state=instance.getState();state instanceof PersistentDataHolder?($("+").data(state.getPersistentDataContainer(),value),state.update(!0)):(value=JSON.stringify(core.serialize(value)),state.setMetadata("grakkit:jx",eval(`new LazyMetadataValue(core.plugin, ()=>'${value}')`)),state.update(!0))}},distance:(target,option)=>{try{return $("+").distance(instance.getLocation(),target,option)}catch(error){switch(error){case"invalid-both":case"invalid-source":throw"ImpossibleError: How the fuck are you seeing this error!?";case"invalid-target":throw"TypeError: Argument 1 must be a location, vector, or have a location or vector attached!"}}},drops:item=>{if(_.def(item)){if(item instanceof ItemStack||(item=$("+").instance(item)),item instanceof ItemStack)return $([...instance.getDrops(item)]);throw"TypeError: You must specify an item stack or nothing at all!"}return $([...instance.getDrops()])},get facing(){const data=instance.getBlockData();return data instanceof Directional?$("+").backs("blockFace")[data.getFacing()]:data instanceof Rotatable?$("+").backs("blockFace")[data.getRotation()]:void 0},set facing(value){if("string"==typeof value&&(value=$("+").fronts("blockFace")[value]),!(value instanceof BlockFace))throw"TypeError: You must specify a block face!";{const data=instance.getBlockData();data instanceof Directional?(data.setFacing(value),instance.setBlockData(data)):data instanceof Rotatable&&(data.setRotation(value),instance.setBlockData(data))}},get instance(){return instance},get location(){return instance.getLocation()},get material(){return $("+").backs("material")[instance.getType()]},set material(value){if("string"==typeof value&&(value=$("+").fronts("material")[value]),!(value instanceof Material))throw"TypeError: You must specify a material!";instance.setType(value)},get vector(){return instance.getLocation().toVector()},get world(){return instance.getWorld()},get x(){return instance.getX()},get y(){return instance.getY()},get z(){return instance.getZ()}};return block};export const parser=(_,$)=>thing=>{throw"SyntaxError: Blocks cannot be parsed and serialized!"};export const chain=(_,$)=>({data:"appender",distance:"runner",drops:"runner",facing:"setter",instance:"getter",location:"getterLink",material:"setter",serialize:thing=>{throw"SyntaxError: Blocks cannot be parsed and serialized!"},vector:"getterLink",world:"getter",x:"getter",y:"getter",z:"getter"});