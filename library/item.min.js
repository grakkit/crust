const UUID=Java.type("java.util.UUID"),Material=Java.type("org.bukkit.Material"),ItemFlag=Java.type("org.bukkit.inventory.ItemFlag"),NamespacedKey=Java.type("org.bukkit.NamespacedKey");export const wrapper=(_,$)=>instance=>{const meta=instance.getItemMeta(),thing={get amount(){return instance.getAmount()},set amount(value){if("number"!=typeof value)throw"TypeError: You must supply a numeric value!";instance.setAmount(_.clamp(value,1,127))},get damage(){if(meta)return meta.getDamage()},set damage(value){if("number"!=typeof value)throw"TypeError: You must supply a numeric value!";thing.meta=meta=>meta.setDamage(_.clamp(value,0,instance.getType().getMaxDurability()))},get data(){if(meta)return $("+").data(meta.getPersistentDataContainer())},set data(value){if("object"!=typeof value)throw"TypeError: You must supply an object or null value!";thing.meta=meta=>$("+").data(meta.getPersistentDataContainer(),value)},get destroyable(){return _.array(meta.getDestroyableKeys()).map(key=>key.getKey())},set destroyable(value){if(!_.iterable(value))throw"TypeError: You must supply an array of destroyable keys!";value=value.map(entry=>{if("string"==typeof entry&&(entry=entry.includes(":")?new NamespacedKey(...entry.split(":")):($("+").fronts("material")[entry]||{getKey:()=>{}}).getKey()),entry instanceof NamespacedKey)return entry;throw"TypeError: That array contains invalid destroyable keys!"}),thing.meta=meta=>meta.setDestroyableKeys(_.collect(...value))},drop:(location,option)=>{try{return $("+").drop(location,instance,option)}catch(error){switch(error){case"invalid-both":case"invalid-item":throw"ImpossibleError: How the fuck are you seeing this error!?";case"invalid-location":throw"TypeError: Argument 1 must be a location!"}}},get enchantments(){return _.define($("+").fronts("enchantment"),entry=>{if(meta)return{get:()=>"enchanted_book"===thing.material?meta.getStoredEnchantLevel(entry.value):meta.getEnchantLevel(entry.value),set:value=>{if("number"!=typeof value)throw"TypeError: You must supply a numeric value!";thing.meta=meta=>{value?"enchanted_book"!==thing.material?meta.addEnchant(entry.value,value,!0):meta.addStoredEnchant(entry.value,value,!0):"enchanted_book"===thing.material?meta.removeStoredEnchant(entry.value):meta.removeEnchant(entry.value)}}}})},set enchantments(value){if("object"!=typeof value)throw"TypeError: You must supply an object or a null value!";value||(value={});try{_.keys($("+").fronts("enchantment")).forEach(key=>thing.enchantment[key]=value[key]||null)}catch(error){throw"TypeError: That input contains invalid entries!"}},get flags(){return _.array(meta.getItemFlags()).map(flag=>$("+").backs("itemFlag")[flag])},set flags(value){if(!_.iterable(value))throw"TypeError: You must supply an array!";value=value.map(entry=>{if(entry instanceof ItemFlag||(entry=$("+").fronts("itemFlag")[entry]),entry)return entry;throw"TypeError: That is not a valid item flag!"}),thing.meta=meta=>{meta.removeItemFlags(..._.values($("+").fronts("itemFlag"))),meta.addItemFlags(...value)}},get instance(){return instance},get lore(){if(meta)return meta.getLore()&&_.array(meta.getLore())},set lore(value){if("function"!=typeof value[Symbol.iterator])throw"You must supply an array or string value!";thing.meta=meta=>meta.setLore(_.iterable(value)?value:value.split("\n"))},get material(){return $("+").backs("material")[instance.getType()]},set material(value){const type=value instanceof Material?value:$("+").fronts("material")[value];if(!type)throw"ReferenceError: That is not a valid material!";instance.setType(type)},get meta(){return meta},set meta(value){if("function"!=typeof value)throw"TypeError: You must supply a function!";meta&&value(meta),meta&&instance.setItemMeta(meta)},modifier:uuid=>{try{"string"==typeof uuid&&(uuid=_.uuid(uuid))}catch(value){throw"SyntaxError: Can not convert input to UUID!"}if(!(uuid instanceof UUID))throw"TypeError: You must supply a string value or a UUID!";if(meta){let match;return _.values(Object.assign({},thing.modifiers)).forEach(mods=>{mods.instance().forEach(mod=>{!match&&uuid===mod.getUniqueId()&&(match=$(mod))})}),match||(match=$({format:"modifier",uuid:uuid.toString(),amount:0,operation:"add_number",slot:null})),match}},get modifiers(){return _.define($("+").fronts("attribute"),entry=>{if(meta)return{get:()=>{const modifiers=meta.hasAttributeModifiers()&&meta.getAttributeModifiers(entry.value);return $(_.array(modifiers||[]))},set:value=>{if(_.iterable(value))value=value.map(mod=>{if("number"==typeof mod&&(mod={amount:mod}),"object"==typeof mod&&"number"==typeof mod.amount)return mod.format="modifier",mod.slot||(mod.slot=null),mod.operation||(mod.operation="add_number"),mod.uuid||(mod.uuid=_.uuid().toString()),mod;throw"TypeError: That array contains an invalid modifier!"}),thing.meta=meta=>{meta.removeAttributeModifier(entry.value),value.map(mod=>meta.addAttributeModifier(entry.value,$(mod).instance()))};else{if(null!==value)throw"TypeError: You must supply a null value or an array of modifiers!";thing.meta=meta=>{meta.removeAttributeModifier(entry.value)}}}}})},set modifiers(value){if("object"!=typeof value)throw"TypeError: You must supply an object or a null value!";value||(value={});try{_.keys($("+").fronts("attribute")).forEach(key=>thing.modifiers[key]=value[key]||null)}catch(error){throw"TypeError: That input contains invalid entries!"}},get bars(){if(player)return _.array(server.getBossBars())},set bars(value){if(!_.iterable(value))throw"TypeError: You must supply an array of namespaced keys!";{const input=value.map(key=>{try{return key instanceof NamespacedKey?key:new NamespacedKey(...key.split(":"))}catch(error){throw"TypeError: That array contains invalid namespaced keys!"}});player&&thing.bars.forEach(bar=>bar.removePlayer(instance)),player&&input.forEach(key=>server.getBossBar(key).addPlayer(instance))}},get name(){if(meta)return meta.getDisplayName()},set name(value){if("string"!=typeof value)throw"TypeError: You must supply a string value!";thing.meta=meta=>meta.setDisplayName(value)},get nbt(){return _.serialize(instance.getHandle().getTag())},set nbt(data){try{return instance.getHandle().setTag(_.parse(data))}catch(error){throw"SyntaxError: Cannot convert input to NBT!"}},get placeable(){return _.array(meta.getPlaceableKeys()).map(key=>key.getKey())},set placeable(value){if(!_.iterable(value))throw"TypeError: You must supply an array of placeable keys!";value=value.map(entry=>{if("string"==typeof entry&&(entry=entry.includes(":")?new NamespacedKey(...entry.split(":")):($("+").fronts("material")[entry]||{getKey:()=>{}}).getKey()),entry instanceof NamespacedKey)return entry;throw"TypeError: That array contains invalid placeable keys!"}),thing.meta=meta=>meta.setPlaceableKeys(_.collect(...value))},get title(){return instance.getI18NDisplayName()},get unbreakable(){if(meta)return meta.isUnbreakable()},set unbreakable(value){if("boolean"!=typeof value)throw"TypeError: You must supply a boolean value!";thing.meta=meta=>meta.setUnbreakable(value)}};return thing};export const parser=(_,$)=>input=>$(`!${input.material}`).amount(input.amount).nbt(input.nbt);export const chain=(_,$)=>({amount:"setter",damage:"setter",data:"appender",destroyable:"setter",drop:"runnerLink",enchantments:"setterNest",flags:"setter",instance:"getter",lore:"setter",material:"setter",meta:(thing,value)=>(_.def(value)&&(thing.meta=value),thing.meta),modifier:"runnerLink",modifiers:"setterLinkNest",name:"setter",nbt:"appender",placeable:"setter",serialize:thing=>_.def(thing)?{format:"item",material:thing.material,amount:thing.amount,nbt:thing.nbt}:null,title:"getter",unbreakable:"setter"});